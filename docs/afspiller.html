<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Afspiller</title>
  <link id="theme-link" rel="stylesheet" href="style.css">
</head>
<body>
<div class="container">
  <div id="podcast-info" class="podcast-info"></div>
  <div id="pagination-controls" class="pagination-controls">
    <button id="prev-page" class="pagination-button" aria-label="Previous Page">←</button>
    <span id="page-info" class="page-info" role="region" aria-live="polite">
      <span id="current-page" contenteditable="true" aria-label="Current Page">1</span> / 
      <span id="total-pages" aria-label="Total Pages">1</span>
    </span>
    <button id="next-page" class="pagination-button" aria-label="Next Page">→</button>
  </div>
  <div id="theme-toggle" class="theme-toggle" aria-label="Toggle Theme"></div>
</div>

<audio id="audio-player" controls preload="none" style="width: 500px; position: fixed; bottom: 0; left: 50%; transform: translateX(-50%);" aria-label="Podcast Player">
  Din browser understøtter ikke direkte afspilning af lydfiler
</audio>

<div id="loading-spinner" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);">Loading...</div>

<script>
let currentPage = 1;
let totalEpisodes = 0;
const itemsPerPage = 10;
let episodesData = [];

async function loadPodcast() {
  try {
    document.getElementById("loading-spinner").style.display = "block";
    const params = new URLSearchParams(window.location.search);
    const rssUrl = params.get("rss");
    if (!rssUrl) {
        throw new Error("Ugyldig RSS");
    }

    const response = await fetch(rssUrl);
    if (!response.ok) {
      throw new Error(`Netværksfejl: ${response.statusText}`);
    }

    const rssText = await response.text();
    const parser = new DOMParser();
    const rssDoc = parser.parseFromString(rssText, "application/xml");

    if (rssDoc.querySelector("parsererror")) {
      throw new Error("Ugyldigt XML-format");
    }

    const channel = rssDoc.querySelector("channel");
    if (!channel) {
      throw new Error("Ugyldig RSS: Mangler hovedkanal i feed");
    }

    const title = channel.querySelector("title")?.textContent || "(ingen titel)";
    const description = channel.querySelector("description")?.textContent || "(ingen beskrivelse)";
    const episodes = channel.querySelectorAll("item");

    totalEpisodes = episodes.length;

    episodesData = Array.from(episodes).map((episode) => {
      return {
        title: episode.querySelector("title")?.textContent || "(ingen titel)",
        description: episode.querySelector("description")?.textContent || "(ingen beskrivelse)",
        pubDate: new Date(episode.querySelector("pubDate")?.textContent),
        link: episode.querySelector("enclosure")?.getAttribute("url"),
      };
    });

    document.getElementById("podcast-info").innerHTML = `<h2>${title}</h2><p>${description}</p>`;
    displayEpisodes();
  } catch (error) {
    document.getElementById("podcast-info").innerHTML = `<p>Indlæsningsfejl: ${error.message}</p>`;
    console.error("Error loading podcast data:", error);
  } finally {
    document.getElementById("loading-spinner").style.display = "none";
  }
}

function displayEpisodes() {
  const startIndex = (currentPage - 1) * itemsPerPage;
  const endIndex = startIndex + itemsPerPage;
  const totalPages = Math.ceil(totalEpisodes / itemsPerPage);
  document.getElementById("total-pages").textContent = totalPages;

  episodesData.sort((a, b) => {
    return new Date(a.pubDate) - new Date(b.pubDate);
  });

  const episodesToShow = episodesData.slice(startIndex, endIndex);

  let episodesHTML = '';

  episodesToShow.forEach((episode) => {
    episodesHTML += `
      <div class="episode" data-url="${episode.link}" data-title="${episode.title.replace(/'/g, "\\'")}">
        <h4 class="episode-title">${episode.title}</h4>
        <p class="pub-date">${episode.pubDate.toLocaleDateString()}</p>
        <p class="episode-description">${episode.description}</p>
      </div>
    `;
  });

  document.getElementById("podcast-info").innerHTML += episodesHTML;
  attachEpisodeClickListeners();
  attachDescriptionToggleListeners();
  updatePaginationControls();
}

function attachEpisodeClickListeners() {
  document.querySelectorAll('.episode').forEach((episodeElement) => {
    episodeElement.addEventListener('click', (event) => {
      if (!event.target.classList.contains('episode-description')) {
        const episodeUrl = episodeElement.getAttribute('data-url');
        const episodeTitle = episodeElement.getAttribute('data-title');
        playEpisode(episodeUrl, episodeTitle);
      }
    });
  });
}

function attachDescriptionToggleListeners() {
  document.querySelectorAll('.episode-description').forEach((description) => {
    description.addEventListener('click', (event) => {
      event.stopPropagation();
      if (description.style.maxHeight) {
        description.style.maxHeight = null;
        description.classList.remove('expanded');
      } else {
        description.style.maxHeight = description.scrollHeight + "px";
        description.classList.add('expanded');
      }
    });
  });
}

function updatePaginationControls() {
  document.getElementById("current-page").textContent = currentPage;
  const totalPages = parseInt(document.getElementById("total-pages").textContent);
  document.getElementById("prev-page").disabled = currentPage === 1;
  document.getElementById("next-page").disabled = currentPage === totalPages;
}

function changePage(increment) {
  currentPage += increment;
  document.querySelectorAll('.episode').forEach(episode => episode.remove());
  displayEpisodes();
}

function playNextEpisode() {
  const playingEpisode = document.querySelector('.episode.playing');
  const episodes = Array.from(document.querySelectorAll('.episode'));
  const currentIndex = episodes.indexOf(playingEpisode);

  if (currentIndex < episodes.length - 1) {
    const nextEpisode = episodes[currentIndex + 1];
    const episodeUrl = nextEpisode.getAttribute('data-url');
    const episodeTitle = nextEpisode.getAttribute('data-title');
    playEpisode(episodeUrl, episodeTitle);
  } else {
    const totalPages = parseInt(document.getElementById("total-pages").textContent);
    if (currentPage < totalPages) {
      changePage(1);
      setTimeout(() => {
        const firstEpisode = document.querySelector('.episode');
        const episodeUrl = firstEpisode.getAttribute('data-url');
        const episodeTitle = firstEpisode.getAttribute('data-title');
        playEpisode(episodeUrl, episodeTitle);
        window.scrollTo({ top: 0, behavior: 'smooth' })
      }, 100);
    }
  }
}

function playEpisode(episodeUrl, episodeTitle) {
  const audioPlayer = document.getElementById("audio-player");
  audioPlayer.src = episodeUrl;
  audioPlayer.style.display = "block";
  audioPlayer.play();

  document.title = episodeTitle;

  document.querySelectorAll('.episode').forEach(episode => episode.classList.remove('playing'));
  document.querySelector(`.episode[data-url='${episodeUrl}']`).classList.add('playing');
}



document.addEventListener("DOMContentLoaded", () => {
  loadPodcast();

  document.getElementById("prev-page").addEventListener('click', () => changePage(-1));
  document.getElementById("next-page").addEventListener('click', () => changePage(1));
  
  const currentPageElement = document.getElementById("current-page");
  currentPageElement.addEventListener('focus', (event) => {
    setTimeout(() => {
      document.execCommand('selectAll', false, null);
    }, 0);
  });

  document.getElementById("page-info").addEventListener('keypress', function(event) {
    if (event.key === 'Enter') {
      event.preventDefault();
      const newPage = parseInt(document.getElementById("current-page").textContent);
      const totalPages = parseInt(document.getElementById("total-pages").textContent);
      if (newPage >= 1 && newPage <= totalPages) {
        currentPage = newPage;
        document.querySelectorAll('.episode').forEach(episode => episode.remove());
        displayEpisodes();
      } else {
        document.getElementById("current-page").textContent = currentPage;
      }
      event.target.blur();
    }
  });

  const themeToggle = document.getElementById('theme-toggle');

  const savedTheme = localStorage.getItem('theme');
  if (savedTheme) {
    document.body.classList.add(savedTheme + '-theme');
    themeToggle.textContent = savedTheme === 'dark' ? '☀' : '☽';
  } else {
    document.body.classList.add('light-theme');
    themeToggle.textContent = '☽';
  }

  themeToggle.addEventListener('click', () => {
    document.body.classList.toggle('dark-theme');
    document.body.classList.toggle('light-theme');
    
    if (document.body.classList.contains('dark-theme')) {
      localStorage.setItem('theme', 'dark');
      themeToggle.textContent = '☀';
    } else {
      localStorage.setItem('theme', 'light');
      themeToggle.textContent = '☽';
    }
  });

  const audioPlayer = document.getElementById("audio-player");
  audioPlayer.addEventListener('ended', playNextEpisode);
});

</script>
</body>
</html>
